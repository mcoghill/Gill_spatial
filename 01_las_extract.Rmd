---
title: "01_Extraction"
author: "Matthew Coghill"
date: "9/28/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The main objectives of this script will be to simply extract LAS files from the zipped folders and place them into a new folder for use later on. First, load required packages.

```{r}

ls <- c("tidyverse", "lidR", "xml2", "sf", "future")
new_packages <- ls[!(ls %in% installed.packages()[, "Package"])]
if(length(new_packages)) 
  install.packages(new_packages, Ncpus = cpus)

invisible(suppressPackageStartupMessages(lapply(ls, library, character.only = TRUE)))

```

Next, we can find the .las files located in the zipped folders and extract those specifically. Before doing so though, we will make sure that there is a folder created for their export.

```{r}

# Define directories, create output folder
raw_dir <- file.path("./01_raw")
out_dir <- file.path("./02_las")
dir.create(out_dir, showWarnings = FALSE)

# Extract all files from the LAS folder - this will take a while.
zip_files <- list.files(raw_dir, pattern = ".zip$", full.names = TRUE)
las_files <- lapply(zip_files, function(x) {
  y <- unzip(x, list = TRUE) %>% 
    dplyr::filter(grepl(".las$", Name)) %>% 
    dplyr::pull(Name) %>% 
    dirname()
  yy <- unzip(x, list = TRUE) %>% 
    dplyr::filter(grepl(y, Name)) %>% 
    dplyr::pull(Name)
  xd <- file.path(out_dir, basename(tools::file_path_sans_ext(yy[endsWith(yy, ".las")])))
  dir.create(xd, showWarnings = FALSE)
  unzip(x, yy, junkpaths = TRUE, exdir = xd)
  list.files(xd, full.names = TRUE)
}) 

```

The extracted LAS files are huge. Tiling helps to process things on normal computers a lot more quickly, so perform tiling for each extracted LAS file.

```{r}

las_files <- list.files(out_dir, pattern = ".las$", full.names = TRUE, recursive = TRUE)
tile_dir <- file.path("./03_las_tile")
dir.create(tile_dir, showWarnings = FALSE)

retile <- lapply(las_files[1], function(x) {
  # x <- las_files[1]
  ctg <- readLAScatalog(x)
  tile_out <- file.path(tile_dir, basename(dirname(x)))
  
  # Try snipping to 250m x 250m tiles
  opt_chunk_buffer(ctg) <- 25
  opt_chunk_size(ctg) <- 250
  opt_output_files(ctg) <- file.path(tile_out, paste0(basename(tile_out), 
                                                      "_{XLEFT}_{YBOTTOM}"))
  
  newctg <- catalog_retile(ctg)
  newctg <- readLAScatalog(tile_out)
})


```

Now that the original files are tiled, we must deal with the fact that there is a lack of CRS applied to the X, Y, and Z coordinates. These details are located within the XML files that are extracted from the LAS folder. Then, I want to create a function that will iteratively go through each of the tiles and apply the CRS information to each of the points.

```{r}

# Load the XML information
xml_files <- list.files(out_dir, pattern = ".xml$", full.names = TRUE, recursive = TRUE)

# 1) Create generic function
coord_fix <- function(las, ...) {
  UseMethod("coord_fix", las)
}

# 2) Create method for las objects
coord_fix.LAS <- function(las, xoffset, yoffset, zoffset, crs) {
  las2 <- las_rescale(las, 0.001, 0.001, 0.001)
  las2 <- las_reoffset(las2, xoffset, yoffset, zoffset)
  las2$X <- las2$X + xoffset
  las2$Y <- las2$Y + yoffset
  las2$Z <- las2$Z + zoffset
  crs(las2) <- crs
  return(las2)
}

# 3) Create a method for LAScluster objects (chunk)
coord_fix.LAScluster <- function(las, xoffset, yoffset, zoffset, crs) {
  x <- readLAS(las)
  if (is.empty(x)) return(NULL)
  xx <- coord_fix(x, xoffset, yoffset, zoffset, crs)
  return(xx)
}

# 4) Create a method for LAScatalog objects
coord_fix.LAScatalog <- function(las, xoffset, yoffset, zoffset, crs) {
  opt_select(las) <- "*"
  options <- list(automerge = TRUE, need_output_file = TRUE)
  output <- catalog_apply(las, coord_fix, xoffset = xoffset, yoffset = yoffset,
                          zoffset = zoffset, crs = crs, .options = options)
  return(output)
}

# start lapply loop here
x <- xml_files[1]

crs_data <- as_list(read_xml(x))

origin <- crs_data$ModelMetadata$SRS[[1]]

# Remove first 4 characters of string
origin <- substr(origin, 5, nchar(origin))

# Convert to numbers and reverse order
origin <- rev(as.numeric(unlist(strsplit(origin, ","))))

# Convert to point
org_pt <- st_sfc(st_point(origin), crs = 4326)

# Transform to BC Albers (note: should also check with UTM's)
org_pt_bca <- st_transform(org_pt, 3005)

# Get points of origin
org_x <- st_coordinates(org_pt_bca)[, "X"]
org_y <- st_coordinates(org_pt_bca)[, "Y"]
org_z <- as.numeric(unlist(strsplit(crs_data[[1]]$SRSOrigin[[1]], ",")))[3]

# Run custom function
ctg_in_dir <- file.path(tile_dir, basename(dirname(x)))
ctg_out_dir <- file.path("./04_fixed_coords", basename(dirname(x)))
dir.create(ctg_out_dir, showWarnings = FALSE, recursive = TRUE)
ctg <- readLAScatalog(ctg_in_dir)
opt_chunk_buffer(ctg) <- 0
opt_output_files(ctg) <- file.path(ctg_out_dir, "{ORIGINALFILENAME}")
newctg <- coord_fix(ctg, org_x, org_y, org_z, 3005)

```


```{r}

# Ground classification
las <- readLAS(list.files(ctg_out_dir, full.names = TRUE)[5])
las_grnd <- classify_ground(las, csf())
las_norm <- normalize_height(las_grnd, tin())

# Get CHM
algo = pitfree(thresholds = c(0,10,20,30,40,50), subcircle = 0.2, max_edge = c(3, 1.5))
chm  = grid_canopy(las, 0.5, algo)
plot(chm, col = height.colors(50))

# Smoothing
ker = matrix(1,3,3)
chm = focal(chm, w = ker, fun = median)
chm = focal(chm, w = ker, fun = median)

# Tree segmentation
algo = watershed(chm, th = 4)
las2 = segment_trees(las_norm, algo)

# remove points that are not assigned to a tree
trees = filter_poi(las2, !is.na(treeID))

plot(trees, color = "treeID", colorPalette = pastel.colors(100))

# Compute hulls
hulls = st_as_sf(delineate_crowns(las2, func = .stdmetrics))

```

After some reading last night, I found that the simplest way to do this is to add coordinates to the X/Y parameters. The coordinates must be in a projected format that uses meters (BC Albers or UTM).

